/*
 * Copyright 2025 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.adk.models.springai;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.springframework.ai.embedding.Embedding;
import org.springframework.ai.embedding.EmbeddingRequest;
import org.springframework.ai.embedding.EmbeddingResponse;

/**
 * Utility class for converting between embedding formats and performing vector operations.
 *
 * <p>This class provides helper methods for working with embeddings generated by Spring AI models,
 * including format conversions and similarity calculations.
 */
public class EmbeddingConverter {

  private EmbeddingConverter() {
    // Utility class - prevent instantiation
  }

  /**
   * Create an EmbeddingRequest for a single text input.
   *
   * @param text The text to embed
   * @return EmbeddingRequest for the text
   */
  public static EmbeddingRequest createRequest(String text) {
    return new EmbeddingRequest(List.of(text), null);
  }

  /**
   * Create an EmbeddingRequest for multiple text inputs.
   *
   * @param texts The texts to embed
   * @return EmbeddingRequest for the texts
   */
  public static EmbeddingRequest createRequest(List<String> texts) {
    return new EmbeddingRequest(texts, null);
  }

  /**
   * Extract embedding vectors from an EmbeddingResponse.
   *
   * @param response The embedding response
   * @return List of embedding vectors as float arrays
   */
  public static List<float[]> extractEmbeddings(EmbeddingResponse response) {
    List<float[]> embeddings = new ArrayList<>();
    for (Embedding embedding : response.getResults()) {
      embeddings.add(embedding.getOutput());
    }
    return embeddings;
  }

  /**
   * Extract the first embedding vector from an EmbeddingResponse.
   *
   * @param response The embedding response
   * @return The first embedding vector, or null if no embeddings
   */
  public static float[] extractFirstEmbedding(EmbeddingResponse response) {
    if (response.getResults().isEmpty()) {
      return null;
    }
    return response.getResults().get(0).getOutput();
  }

  /**
   * Calculate cosine similarity between two embedding vectors.
   *
   * @param embedding1 First embedding vector
   * @param embedding2 Second embedding vector
   * @return Cosine similarity score between -1 and 1
   */
  public static double cosineSimilarity(float[] embedding1, float[] embedding2) {
    if (embedding1.length != embedding2.length) {
      throw new IllegalArgumentException(
          "Embedding vectors must have the same dimensions: "
              + embedding1.length
              + " vs "
              + embedding2.length);
    }

    double dotProduct = 0.0;
    double norm1 = 0.0;
    double norm2 = 0.0;

    for (int i = 0; i < embedding1.length; i++) {
      dotProduct += embedding1[i] * embedding2[i];
      norm1 += embedding1[i] * embedding1[i];
      norm2 += embedding2[i] * embedding2[i];
    }

    if (norm1 == 0.0 || norm2 == 0.0) {
      return 0.0; // Handle zero vectors
    }

    return dotProduct / (Math.sqrt(norm1) * Math.sqrt(norm2));
  }

  /**
   * Calculate Euclidean distance between two embedding vectors.
   *
   * @param embedding1 First embedding vector
   * @param embedding2 Second embedding vector
   * @return Euclidean distance
   */
  public static double euclideanDistance(float[] embedding1, float[] embedding2) {
    if (embedding1.length != embedding2.length) {
      throw new IllegalArgumentException(
          "Embedding vectors must have the same dimensions: "
              + embedding1.length
              + " vs "
              + embedding2.length);
    }

    double sum = 0.0;
    for (int i = 0; i < embedding1.length; i++) {
      double diff = embedding1[i] - embedding2[i];
      sum += diff * diff;
    }

    return Math.sqrt(sum);
  }

  /**
   * Normalize an embedding vector to unit length.
   *
   * @param embedding The embedding vector to normalize
   * @return Normalized embedding vector
   */
  public static float[] normalize(float[] embedding) {
    double norm = 0.0;
    for (float value : embedding) {
      norm += value * value;
    }
    norm = Math.sqrt(norm);

    if (norm == 0.0) {
      return Arrays.copyOf(embedding, embedding.length); // Return copy of zero vector
    }

    float[] normalized = new float[embedding.length];
    for (int i = 0; i < embedding.length; i++) {
      normalized[i] = (float) (embedding[i] / norm);
    }

    return normalized;
  }

  /**
   * Find the most similar embedding from a list of candidates.
   *
   * @param query The query embedding
   * @param candidates List of candidate embeddings
   * @return Index of the most similar embedding, or -1 if no candidates
   */
  public static int findMostSimilar(float[] query, List<float[]> candidates) {
    if (candidates.isEmpty()) {
      return -1;
    }

    int bestIndex = 0;
    double bestSimilarity = cosineSimilarity(query, candidates.get(0));

    for (int i = 1; i < candidates.size(); i++) {
      double similarity = cosineSimilarity(query, candidates.get(i));
      if (similarity > bestSimilarity) {
        bestSimilarity = similarity;
        bestIndex = i;
      }
    }

    return bestIndex;
  }

  /**
   * Calculate similarity scores between a query and all candidates.
   *
   * @param query The query embedding
   * @param candidates List of candidate embeddings
   * @return List of similarity scores
   */
  public static List<Double> calculateSimilarities(float[] query, List<float[]> candidates) {
    List<Double> similarities = new ArrayList<>();
    for (float[] candidate : candidates) {
      similarities.add(cosineSimilarity(query, candidate));
    }
    return similarities;
  }

  /**
   * Convert float array to double array.
   *
   * @param floatArray The float array
   * @return Equivalent double array
   */
  public static double[] toDoubleArray(float[] floatArray) {
    double[] doubleArray = new double[floatArray.length];
    for (int i = 0; i < floatArray.length; i++) {
      doubleArray[i] = floatArray[i];
    }
    return doubleArray;
  }

  /**
   * Convert double array to float array.
   *
   * @param doubleArray The double array
   * @return Equivalent float array
   */
  public static float[] toFloatArray(double[] doubleArray) {
    float[] floatArray = new float[doubleArray.length];
    for (int i = 0; i < doubleArray.length; i++) {
      floatArray[i] = (float) doubleArray[i];
    }
    return floatArray;
  }
}
